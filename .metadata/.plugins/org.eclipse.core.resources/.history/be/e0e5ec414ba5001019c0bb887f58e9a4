package com.cp.workskillai.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class GeminiAIService {

    @Value("${gemini.api.key}")
    private String geminiApiKey;

    private final ObjectMapper objectMapper;

    public Map<String, Object> analyzeResume(MultipartFile file) {
        try {
            log.info("Starting Gemini AI analysis for file: {}", file.getOriginalFilename());
            
            // Extract text from file
            String resumeText = extractTextFromFile(file);
            
            // Prepare prompt for Gemini
            String prompt = createAnalysisPrompt(resumeText);
            
            // Call Gemini API
            String response = callGeminiAPI(prompt);
            
            // Parse response
            Map<String, Object> result = parseGeminiResponse(response);
            
            log.info("Gemini AI analysis completed successfully");
            return result;
            
        } catch (Exception e) {
            log.error("Gemini AI analysis failed", e);
            return getFallbackAnalysisData();
        }
    }

    private String extractTextFromFile(MultipartFile file) throws Exception {
        String contentType = file.getContentType();
        
        if (contentType == null) {
            throw new RuntimeException("Unable to determine file type");
        }

        try (InputStream inputStream = file.getInputStream()) {
            switch (contentType) {
                case "text/plain":
                    return new String(file.getBytes());
                    
                case "application/pdf":
                    return extractTextFromPdf(inputStream);
                    
                case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
                    return extractTextFromDocx(inputStream);
                    
                default:
                    throw new RuntimeException("Unsupported file type: " + contentType);
            }
        } catch (Exception e) {
            log.error("Error extracting text from file: {}", file.getOriginalFilename(), e);
            throw new RuntimeException("Failed to extract text from file: " + e.getMessage());
        }
    }

    private String extractTextFromPdf(InputStream inputStream) throws Exception {
        try (PDDocument document = PDDocument.load(inputStream)) {
            PDFTextStripper pdfStripper = new PDFTextStripper();
            pdfStripper.setSortByPosition(true);
            return pdfStripper.getText(document);
        }
    }

    private String extractTextFromDocx(InputStream inputStream) throws Exception {
        try (XWPFDocument document = new XWPFDocument(inputStream)) {
            StringBuilder text = new StringBuilder();
            
            // Extract paragraphs
            for (XWPFParagraph paragraph : document.getParagraphs()) {
                text.append(paragraph.getText()).append("\n");
            }
            
            // Extract tables
            for (XWPFTable table : document.getTables()) {
                for (XWPFTableRow row : table.getRows()) {
                    for (XWPFTableCell cell : row.getTableCells()) {
                        text.append(cell.getText()).append("\t");
                    }
                    text.append("\n");
                }
            }
            
            return text.toString();
        }
    }

    private String createAnalysisPrompt(String resumeText) {
        return """
            Analyze this resume text and extract structured information. Return ONLY valid JSON.
            
            RESUME TEXT:
            %s
            
            Extract into this exact JSON structure:
            {
              "fullName": "extracted full name",
              "email": "extracted email",
              "contactNumber": "extracted phone number",
              "title": "extracted job title",
              "skills": ["array of technical skills"],
              "certifications": ["array of certification names"],
              "education": [
                {
                  "degree": "degree name",
                  "institution": "institution name", 
                  "year": "graduation year"
                }
              ],
              "experience": [
                {
                  "position": "job position",
                  "company": "company name", 
                  "duration": "employment duration",
                  "description": "job description"
                }
              ],
              "summary": "professional summary"
            }
            
            Rules:
            - Return ONLY valid JSON, no other text
            - Use empty strings/arrays for missing data
            - Remove any special characters that break JSON
            """.formatted(resumeText.substring(0, Math.min(resumeText.length(), 3000)));
    }

    private String callGeminiAPI(String prompt) throws Exception {
        String url = "https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent?key=" + geminiApiKey;
        
        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();
        connection.setRequestMethod("POST");
        connection.setRequestProperty("Content-Type", "application/json");
        connection.setDoOutput(true);
        
        String requestBody = """
            {
              "contents": [{
                "parts": [{
                  "text": "%s"
                }]
              }],
              "generationConfig": {
                "temperature": 0.1,
                "topK": 40,
                "topP": 0.95,
                "maxOutputTokens": 2048
              }
            }
            """.formatted(prompt.replace("\"", "\\\""));
        
        connection.getOutputStream().write(requestBody.getBytes());
        
        int responseCode = connection.getResponseCode();
        if (responseCode != 200) {
            throw new RuntimeException("Gemini API request failed with code: " + responseCode);
        }
        
        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        StringBuilder response = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            response.append(line);
        }
        reader.close();
        
        return response.toString();
    }

    private Map<String, Object> parseGeminiResponse(String response) throws Exception {
        // Parse the Gemini API response and extract the text content
        Map<String, Object> responseMap = objectMapper.readValue(response, Map.class);
        List<Map<String, Object>> candidates = (List<Map<String, Object>>) responseMap.get("candidates");
        Map<String, Object> content = (Map<String, Object>) candidates.get(0).get("content");
        List<Map<String, Object>> parts = (List<Map<String, Object>>) content.get("parts");
        String text = (String) parts.get(0).get("text");
        
        // Clean and parse the JSON response
        String cleanedJson = text.replace("```json", "").replace("```", "").trim();
        return objectMapper.readValue(cleanedJson, Map.class);
    }

    private Map<String, Object> getFallbackAnalysisData() {
        return Map.of(
            "fullName", "",
            "email", "",
            "contactNumber", "",
            "skills", List.of(),
            "certifications", List.of(),
            "education", List.of(),
            "experience", List.of(),
            "summary", ""
        );
    }
}